# Week27
1.Потому что math.random () возвращает псевдослучайное число с плавающей запятой из диапазона [0, 1). А это может ухудшить производительность кода.

2.
  onClick = (id, title) => (e) => {
        e.preventDefault();
        this.setState({ count: this.state.count + 1 });
    };

  render() {
      const {id} = this.props;
      const {title} = this.title
      const {count} = this.state;
      return (
        <h2>{title}</h2>
        <a href="#" onClick={this.onClick(id)}>click {count}</a>);
  }

3.Вместо того, чтобы взаимодействовать с DOM напрямую, с помощью VirtualDOM мы работаем с его легковесной копией. Мы можем вносить изменения в копию, исходя из наших потребностей, а после этого применять изменения к реальному DOM.
При этом происходит сравнение DOM-дерева с его виртуальной копией, определяется разница и запускается перерисовка того, что было изменено.

4.handleChange = () => {
	console.log('foo');

	this.setState({                          
		checked: !this.state.checked, 
		},
		()=>{console.log('baz')}
	);
	console.log('bar') 
};

Первый - console.log('foo');
Второй - console.log('bar') 
Третий - console.log('baz')

5.Ref решают проблему:
-выделения текста, фокусов и проигрывания медиа;
-вызова методов дочерних компонентов из родительских.

6.Возможно потому, что эти компоненты будут сильнее связаны между собой. Когда же философия Реакт подразумевает использование компонентов как вместе так и независимо друг от друга.

7.Можно, но смысла в этом нет, потому что передачу от родительских компонентов к дочерним выполняют props.

8.Кастомный хук - это функция, которая выносит логику компонента в отдельную единицу для повторного использования. Основное отличие кастомных хуков от обычных функций заключается в использовании внутри них стандартных хуков React, таких как useState, useEffect и т.д. Кастомные хуки, подобно стандартным, предназначены для использования внутри функциональных компонентов.